
---
Date: 20 Feb, 2023
Tags: dsa
fileClass: Problem
---
Topics:: 
Difficulty::  Medium
Understanding:: 
## Problem: 
 Given an array of `intervals` where `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

	Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
	Output: [[1,6],[8,10],[15,18]]
	Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

**Example 2:**

	Input: intervals = [[1,4],[4,5]]
	Output: [[1,5]]
	Explanation: Intervals [1,4] and [4,5] are considered overlapping.

[Link]( https://leetcode.com/problems/merge-intervals/)

## Notes: 
- First sort the array based on the start intervals and then compare neighboring intervals 

## Solutions: 

- Solution 1: 
	```java
	
	public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(o->o[0]));
        List<List<Integer>> list = new ArrayList<>();
        list.add(List.of(intervals[0][0], intervals[0][1]));
        
        for(int i = 1; i<intervals.length; i++){
            int prevStart = list.get(list.size()-1).get(0);
            int prevEnd = list.get(list.size()-1).get(1);

            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            if(prevEnd < currStart){
                list.add(List.of(currStart, currEnd));
            } else {
                list.set(list.size()-1, List.of(prevStart, Math.max(prevEnd, currEnd)));
            }
        }
        int[][] ans = new int[list.size()][2];
        int i = 0;
        for(List<Integer> interval : list){
            ans[i][0] = interval.get(0);
            ans[i][1] = interval.get(1);
            i++;
        }

        return ans;
    }
	
	```
	Complexity: 
	- Time: O(N)
	- Space: O(N) above solution uses 2N

