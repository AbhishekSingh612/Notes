### Problem Statement[](https://dvpr.gitbook.io/coding-interview-patterns/1.-pattern-sliding-window/1.2-smallest-subarray-with-a-given-sum-easy#problem-statement)

**Given an array of positive numbers and a positive number ‘S,’ find the length of the smallest contiguous subarray whose sum is greater than or equal to ‘S’. Return 0 if no such subarray exists.**

Example 1:

	Input: [2, 1, 5, 2, 3, 2], S=7
	Output: 2
	Explanation: The smallest subarray with a sum greater than or equal to '7' is [5, 2].

Example 2:

	Input: [2, 1, 5, 2, 8], S=7
	Output: 1
	Explanation: The smallest subarray with a sum greater than or equal to '7' is [8].

Example 3:

	Input: [3, 4, 1, 1, 6], S=8
	Output: 3
	Explanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6].

[Leetcode](https://leetcode.com/problems/minimum-size-subarray-sum/description/)

```java
public int minSubArrayLen(int target, int[] nums) {

        int left = 0, right = 0, len = nums.length;
        int minLen = Integer.MAX_VALUE;
        int windowSum = 0;
        
        for(right=0; right < len; right++){
            windowSum += nums[right];

            while(windowSum >= target){
                minLen = Math.min(minLen, (right - left + 1));
                windowSum -= nums[left];
                left++;
            }
        }
        return (minLen==Integer.MAX_VALUE)? 0 : minLen;
    }
```

```java
    public int minSubArrayLen(int target, int[] nums) {

        int left = 0, right = 0, len = nums.length;
        int minLen = Integer.MAX_VALUE;
        int windowSum = 0;
        
        while(right < len){
            windowSum += nums[right];

            while(windowSum >= target){
                minLen = Math.min(minLen, (right - left + 1));
                windowSum -= nums[left];
                left++;
            }
            right++;
        }
        return (minLen==Integer.MAX_VALUE)? 0 : minLen;
    }
}
```

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0, right = 0, len = nums.length;
        int minLen = Integer.MAX_VALUE;

        int windowSum = 0;
        while(right < len){
            windowSum += nums[right];
            
            if(windowSum < target){
               right++;
            }
            else{
                minLen = Math.min(minLen, (right - left + 1));
                
                //subtracting right as we are not incrementing right 
                //and next iteration will add nums[right] hence to remove duplication 
                windowSum =windowSum - nums[left] - nums[right];
                left++;
            }           
        }

        return (minLen==Integer.MAX_VALUE)? 0 : minLen;
    }
}
```
